{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to what I've learned This is where I step out of my comfort zone. I'm using this to stretch into new territory and to help improve my communication style. The content here is presented in a way I feel my past-self would have best learned it.","title":"Home"},{"location":"#welcome-to-what-ive-learned","text":"This is where I step out of my comfort zone. I'm using this to stretch into new territory and to help improve my communication style. The content here is presented in a way I feel my past-self would have best learned it.","title":"Welcome to what I've learned"},{"location":"git/branching_examples/","text":"Branches and why they matter Start by executing the following commands to create a directory, navigate into the directory, and initialize the repository. mkdir Branching\\ example cd Branching\\ example/ git init Helpful hint: If seeing things as they occur helps you open a file explorer to the current directory so it is visible while you execute the commands that follow. With the repository created we need content to commit. Execute the commands below. They create a text file with the output of the echo command redirected and saved to a text file, add any and all files to staging-area, then commit all staged files with a commit message. echo \"Text to start\" > RandomFileName.txt git add . git commit -m \"Initial commit\" The repository right now has a single commit. Create a development branch and commit to it The first command git switch includes the -c \\<new-branch> option to create a new branch with the given name using the currently checked out master branch as the starting point. As before files will be created, added, then committed. git switch -c InitialBranch echo \"Apples are tasty\" > Apples.txt echo \"Bread is a staple food for me\" > Bread.txt echo \"Croutons go on salads\" > Croutons.txt echo \"Danishes are deserts\" > Danishes.txt echo \"Eggs come from chickens\" > Eggs.txt echo \"Frech toast combines eggs with bread\" > FrenchToast.txt echo \"Grapes, purple ones especially, always make me think of Grimace\" > Grapes.txt git add Apples.txt git commit -m \"Add apples file\" git add Bread.txt Croutons.txt git commit -m \"Add bread and croutons file\" git add . git commit -m \"Add files: danish, egg, french toast, grapes\" We now have a branch that contains the changes we just made. The graph shows the most recent commits first stepping backwards in history to the first commit. Change back to the master branch with git switch master to see the only file existing at that commit is RandomFileName.txt. Changing to another branch helps keep you from crossing the streams and maintain separate workflows. Creating another development branch and commit some more Once again we create another branch, create files, and commit them. git switch -c SecondaryBranch echo \"Z has no foods I can think of\" > Z.txt echo \"Yogurt has bacteria\" > Yogurt.txt echo \"X doesn't have any foods either\" > X.txt echo \"Watermellon is a summer time treat\" > Watermellon.txt echo \"Vanilla is one of my favorite flavors. True connoiseurs prefer it over chocolate.\" > Vanilla.txt echo \"Ube is an ingredient in halo-halo, a yummy Fillipino desert\" > Ube.txt echo \"Tapioca is something I haven't had since I was a child\" > Tapioca.txt echo \"Sugar rots your teeth like reality TV rots your brain\" > Sugar.txt echo \"Ranch dressing is inferior to Bleu cheese\" > RanchDressing.txt echo \"Quesadillas are a starving college student staple\" > Quesadilla.txt echo \"Papaya is a nasty tasting fruit\" > Papaya.txt echo \"Oatmeal is another starving college student staple\" > Oatmeal.txt echo \"Nutella should be outlawed because it is an abomination\" > Nutella.txt echo \"Menudo fills you up and sticks with you\" > Menudo.txt echo \"Lemons make menudo taste even better\" > Lemon.txt echo \"Kiwi's are the only K food that come to mind\" > Kiwi.txt echo \"Jello reminds me of old people in hospitals\" > Jello.txt echo \"Ice cream should be eaten sparingly\" > IceCream.txt echo \"Halo-halo is a desert I've come to like\" > HaloHalo.txt git add Z.txt X.txt git commit -m \"Add no food files\" git add Oatmeal.txt Quesadilla.txt git commit -m \"Add starving college student files\" git add Menudo.txt Lemon.txt git commit -m \"Add sopas food files\" git add HaloHalo.txt IceCream.txt Ube.txt git commit -m \"Add Fillipino desert files\" git add Nutella.txt Papaya.txt RanchDressing.txt git commit -m \"Undesirable food files\" git add . git commit -m \"Add remaining food files\" Based on the above commits the development graph is as shown below. Execute the branch command git branch to list the 3 branches. The currently checked out branch is indicated by with an * (asterisk). Switch to each of the branches with git switch <BranchName> and review how the files change in the directory. Branches keep work separate After creating the branches above and checking them out it should be more evident that branches help isolate development work flows. Because creating a branch is so easy it helps to create one any time you're working on a new feature. Merging branches together Currently there are two development branches, InitialBranch and SecondaryBranch , containing the various food files. Make another branch with git switch -c MergingInto master in preparation to merging them. The command to bring branches together is git merge . When performing the merge we'll use the --no-ff to prevent a fast-forward merge from occurring so the merge displays in the graph. Execute git merge InitialBranch --no-ff which brings all the commits from InitialBranch into the branch we just created and have checked out. You see this when executing the git log command including the --graph and --oneline options: git log --graph --oneline . Merge the other branch in with git merge SecondaryBranch --no-ff . Below you see where each branch is explicitly merged with the merge commit. Finding merged branches As branches get merged into the primary development branch you can check for these merged branches by including the --merged flag when executing git merge --merged . The corresponding flag for branches not merged is --no-merged git merge --no-merged . To help make the point create another branch based on master , create a file and commit it. git switch -c TertiaryBranch master` touch 1234.txt git add . git commit -m \"Add number file\" For each branch switch to it and run git branch --merged and git branch --no-merged to see the merged and unmerged branches. Deleting branches When a branch is merged into a main branch it can be deleted. Switch to the master branch then merge unmerged development branches. git switch master git merge TertiaryBranch git merge MergingInto Execute git branch --no-merged to confirm there are no unmerged branches, you should see no output. Remove the development branches with git branch -d InitialBranch MergingInto SecondaryBranch TertiaryBranch to leave only master.","title":"git Branching"},{"location":"git/branching_examples/#branches-and-why-they-matter","text":"Start by executing the following commands to create a directory, navigate into the directory, and initialize the repository. mkdir Branching\\ example cd Branching\\ example/ git init Helpful hint: If seeing things as they occur helps you open a file explorer to the current directory so it is visible while you execute the commands that follow. With the repository created we need content to commit. Execute the commands below. They create a text file with the output of the echo command redirected and saved to a text file, add any and all files to staging-area, then commit all staged files with a commit message. echo \"Text to start\" > RandomFileName.txt git add . git commit -m \"Initial commit\" The repository right now has a single commit.","title":"Branches and why they matter"},{"location":"git/branching_examples/#create-a-development-branch-and-commit-to-it","text":"The first command git switch includes the -c \\<new-branch> option to create a new branch with the given name using the currently checked out master branch as the starting point. As before files will be created, added, then committed. git switch -c InitialBranch echo \"Apples are tasty\" > Apples.txt echo \"Bread is a staple food for me\" > Bread.txt echo \"Croutons go on salads\" > Croutons.txt echo \"Danishes are deserts\" > Danishes.txt echo \"Eggs come from chickens\" > Eggs.txt echo \"Frech toast combines eggs with bread\" > FrenchToast.txt echo \"Grapes, purple ones especially, always make me think of Grimace\" > Grapes.txt git add Apples.txt git commit -m \"Add apples file\" git add Bread.txt Croutons.txt git commit -m \"Add bread and croutons file\" git add . git commit -m \"Add files: danish, egg, french toast, grapes\" We now have a branch that contains the changes we just made. The graph shows the most recent commits first stepping backwards in history to the first commit. Change back to the master branch with git switch master to see the only file existing at that commit is RandomFileName.txt. Changing to another branch helps keep you from crossing the streams and maintain separate workflows.","title":"Create a development branch and commit to it"},{"location":"git/branching_examples/#creating-another-development-branch-and-commit-some-more","text":"Once again we create another branch, create files, and commit them. git switch -c SecondaryBranch echo \"Z has no foods I can think of\" > Z.txt echo \"Yogurt has bacteria\" > Yogurt.txt echo \"X doesn't have any foods either\" > X.txt echo \"Watermellon is a summer time treat\" > Watermellon.txt echo \"Vanilla is one of my favorite flavors. True connoiseurs prefer it over chocolate.\" > Vanilla.txt echo \"Ube is an ingredient in halo-halo, a yummy Fillipino desert\" > Ube.txt echo \"Tapioca is something I haven't had since I was a child\" > Tapioca.txt echo \"Sugar rots your teeth like reality TV rots your brain\" > Sugar.txt echo \"Ranch dressing is inferior to Bleu cheese\" > RanchDressing.txt echo \"Quesadillas are a starving college student staple\" > Quesadilla.txt echo \"Papaya is a nasty tasting fruit\" > Papaya.txt echo \"Oatmeal is another starving college student staple\" > Oatmeal.txt echo \"Nutella should be outlawed because it is an abomination\" > Nutella.txt echo \"Menudo fills you up and sticks with you\" > Menudo.txt echo \"Lemons make menudo taste even better\" > Lemon.txt echo \"Kiwi's are the only K food that come to mind\" > Kiwi.txt echo \"Jello reminds me of old people in hospitals\" > Jello.txt echo \"Ice cream should be eaten sparingly\" > IceCream.txt echo \"Halo-halo is a desert I've come to like\" > HaloHalo.txt git add Z.txt X.txt git commit -m \"Add no food files\" git add Oatmeal.txt Quesadilla.txt git commit -m \"Add starving college student files\" git add Menudo.txt Lemon.txt git commit -m \"Add sopas food files\" git add HaloHalo.txt IceCream.txt Ube.txt git commit -m \"Add Fillipino desert files\" git add Nutella.txt Papaya.txt RanchDressing.txt git commit -m \"Undesirable food files\" git add . git commit -m \"Add remaining food files\" Based on the above commits the development graph is as shown below. Execute the branch command git branch to list the 3 branches. The currently checked out branch is indicated by with an * (asterisk). Switch to each of the branches with git switch <BranchName> and review how the files change in the directory.","title":"Creating another development branch and commit some more"},{"location":"git/branching_examples/#branches-keep-work-separate","text":"After creating the branches above and checking them out it should be more evident that branches help isolate development work flows. Because creating a branch is so easy it helps to create one any time you're working on a new feature.","title":"Branches keep work separate"},{"location":"git/branching_examples/#merging-branches-together","text":"Currently there are two development branches, InitialBranch and SecondaryBranch , containing the various food files. Make another branch with git switch -c MergingInto master in preparation to merging them. The command to bring branches together is git merge . When performing the merge we'll use the --no-ff to prevent a fast-forward merge from occurring so the merge displays in the graph. Execute git merge InitialBranch --no-ff which brings all the commits from InitialBranch into the branch we just created and have checked out. You see this when executing the git log command including the --graph and --oneline options: git log --graph --oneline . Merge the other branch in with git merge SecondaryBranch --no-ff . Below you see where each branch is explicitly merged with the merge commit.","title":"Merging branches together"},{"location":"git/branching_examples/#finding-merged-branches","text":"As branches get merged into the primary development branch you can check for these merged branches by including the --merged flag when executing git merge --merged . The corresponding flag for branches not merged is --no-merged git merge --no-merged . To help make the point create another branch based on master , create a file and commit it. git switch -c TertiaryBranch master` touch 1234.txt git add . git commit -m \"Add number file\" For each branch switch to it and run git branch --merged and git branch --no-merged to see the merged and unmerged branches.","title":"Finding merged branches"},{"location":"git/branching_examples/#deleting-branches","text":"When a branch is merged into a main branch it can be deleted. Switch to the master branch then merge unmerged development branches. git switch master git merge TertiaryBranch git merge MergingInto Execute git branch --no-merged to confirm there are no unmerged branches, you should see no output. Remove the development branches with git branch -d InitialBranch MergingInto SecondaryBranch TertiaryBranch to leave only master.","title":"Deleting branches"},{"location":"git/learning_to_understand_git/","text":"Learning to understand git Understanding version control and Git was not easy to learn for me. It took me longer than it should have. Thankfully I was fortunate to have several people willing to help and explain everything to me. The problem was me. I couldn't relate what I was told to anything I already understood. That made it relaly difficult to make progress. I understood the words that were used as part of the explanation but missed the underlying meaning . I was pointed towards git documentation and started reading. Again I read the words but missed the meaning. Despite lack of progress and frustration I continued on, this time searching out tutorials. One that really helped had a visual component . The breadcrumbing introduction it had along with seeing HEAD move as a commit occured made everything very understandable. After completing the tutorial I created a throwaway repository to test and further my understanding. It was at this point that a lot of what I read previously and read started to make sense. Initializing the throwaway-learning repo I created a new directory, started Git Bash on that directory, then ran git init to initialize or start the repo. Adding files Next I added text files manually to the directory. I confirmed that these were seen with git status to display the changes made . Then, as I did previously in the tutorials, I used the add command via git add to add the files to the index git add First\\ file.txt . ***Note - Autocompletion: If you type git add Fir| leaving the cursor blinking at | you can autocomplete the file name with Tab. ***Note - Escape character: The \\ (backslash) is an escape character for the character that follows it, the (space) character. Files with spaces in their names need the spaces to either be escaped in this manner or otherwise enclosed in quotes ' (single quote) or \" (double quote). The following are also valid: git add 'First file.txt' git add \"First file.txt\" Adding files this way places them in the index, a preparation-area. It is a file of interest but isn't yet a part of the repo. Commonly called either staging-area or index, I use them interchangeably. The explicit git add step gives you the control to add only the files you want the repo. Add the other files executing git add . where the . (period) indicates you want to add the new files. Relevant StackOverflow question for adding files . Committing to the repo Now that the three files are in the staging area, add them to the repo via git commit . Execute git commit -m \"Initial commit\" where the -m is a flag/indicator that the following string \"Initial commit\" is the commit-message/descriptive-reason-it-was-added. Detecting differences \u00bfOk now what? Time to see at what git can do for you. Delete one of the files. Execute git status and you'll see that it has been deleted. The file committed to the repository so from this point on it is tracked. Any differences in it, even a single character, will be brought to your attention as a change. Restoring from the repo Suggestion: Before continuing I suggest navigating to the directory you're working in to have it visible. Seeing the next command executed solidified the concept. Because the file was committed to the repo you can restore it. Execute git restore with git restore Second\\ file.txt to bring the file from the repo back into the directory. Now that I saw this in action I continued by creating two new files and editting those already existing. I restored one file with git restore First\\ file.txt , and visually inspected it with a text editor confirming the changes weren't there. Executing git status confirmed no changes were detected. It was restore d back to the same state as when it was added to the repo. Once again I made edits to First file.txt and saved them. Running git status confirmed they were there. \u00bfWhat if I want to restore all the files? I executed git restore . followed by git status to see what changes were left. Naively I was a bit surprised to see files showing. \u00bfWhy are those files there? They shouldn't be there... Wait. Maybe they should be. :click: that's when another git puzzle piece connected; I understood the different areas of git. \"Working Directory\" is just that, the directory-where-work-is-done. Mentally changing the text on the middle arrow to \"Stage changes= git add \" helped. Another image, git-lifecycle, from the documentation made sense as well. When a new file is first seen it is untracked. I checked back up at the previous commands and the new files were indeed \"Untracked files\". After git add the files were in the Staged/Staging-Area, designated as \"Changes to be committed\". My question now was \u00bfhow can I remove these files? I already knew I could delete them normally by right clicking and choosing delete, but this small taste of Command Line Interface (CLI) power had me hooked. I wanted more. I eventually found the command I wanted was git clean . Since I wanted to remove both the remaining untracked files I executed git clean . . As before I watched the directory while I executed the command. Nothing happened. Confused, I then saw the output \"fatal: clean.requireForce...\". Reading the documentation -i was shorthand for --interactive \"Show what would be done and clean files interactively\". Going with that I executed git clean -i . The documentation for interactive mode led me to executing option 1: clean. I forgot to watch the directory to see that they were removed but that didn't matter. At this point I knew I was on my way to learning to understand git.","title":"Learning to understand git"},{"location":"git/learning_to_understand_git/#learning-to-understand-git","text":"Understanding version control and Git was not easy to learn for me. It took me longer than it should have. Thankfully I was fortunate to have several people willing to help and explain everything to me. The problem was me. I couldn't relate what I was told to anything I already understood. That made it relaly difficult to make progress. I understood the words that were used as part of the explanation but missed the underlying meaning . I was pointed towards git documentation and started reading. Again I read the words but missed the meaning. Despite lack of progress and frustration I continued on, this time searching out tutorials. One that really helped had a visual component . The breadcrumbing introduction it had along with seeing HEAD move as a commit occured made everything very understandable. After completing the tutorial I created a throwaway repository to test and further my understanding. It was at this point that a lot of what I read previously and read started to make sense.","title":"Learning to understand git"},{"location":"git/learning_to_understand_git/#initializing-the-throwaway-learning-repo","text":"I created a new directory, started Git Bash on that directory, then ran git init to initialize or start the repo.","title":"Initializing the throwaway-learning repo"},{"location":"git/learning_to_understand_git/#adding-files","text":"Next I added text files manually to the directory. I confirmed that these were seen with git status to display the changes made . Then, as I did previously in the tutorials, I used the add command via git add to add the files to the index git add First\\ file.txt . ***Note - Autocompletion: If you type git add Fir| leaving the cursor blinking at | you can autocomplete the file name with Tab. ***Note - Escape character: The \\ (backslash) is an escape character for the character that follows it, the (space) character. Files with spaces in their names need the spaces to either be escaped in this manner or otherwise enclosed in quotes ' (single quote) or \" (double quote). The following are also valid: git add 'First file.txt' git add \"First file.txt\" Adding files this way places them in the index, a preparation-area. It is a file of interest but isn't yet a part of the repo. Commonly called either staging-area or index, I use them interchangeably. The explicit git add step gives you the control to add only the files you want the repo. Add the other files executing git add . where the . (period) indicates you want to add the new files. Relevant StackOverflow question for adding files .","title":"Adding files"},{"location":"git/learning_to_understand_git/#committing-to-the-repo","text":"Now that the three files are in the staging area, add them to the repo via git commit . Execute git commit -m \"Initial commit\" where the -m is a flag/indicator that the following string \"Initial commit\" is the commit-message/descriptive-reason-it-was-added.","title":"Committing to the repo"},{"location":"git/learning_to_understand_git/#detecting-differences","text":"\u00bfOk now what? Time to see at what git can do for you. Delete one of the files. Execute git status and you'll see that it has been deleted. The file committed to the repository so from this point on it is tracked. Any differences in it, even a single character, will be brought to your attention as a change.","title":"Detecting differences"},{"location":"git/learning_to_understand_git/#restoring-from-the-repo","text":"Suggestion: Before continuing I suggest navigating to the directory you're working in to have it visible. Seeing the next command executed solidified the concept. Because the file was committed to the repo you can restore it. Execute git restore with git restore Second\\ file.txt to bring the file from the repo back into the directory. Now that I saw this in action I continued by creating two new files and editting those already existing. I restored one file with git restore First\\ file.txt , and visually inspected it with a text editor confirming the changes weren't there. Executing git status confirmed no changes were detected. It was restore d back to the same state as when it was added to the repo. Once again I made edits to First file.txt and saved them. Running git status confirmed they were there. \u00bfWhat if I want to restore all the files? I executed git restore . followed by git status to see what changes were left. Naively I was a bit surprised to see files showing. \u00bfWhy are those files there? They shouldn't be there... Wait. Maybe they should be. :click: that's when another git puzzle piece connected; I understood the different areas of git. \"Working Directory\" is just that, the directory-where-work-is-done. Mentally changing the text on the middle arrow to \"Stage changes= git add \" helped. Another image, git-lifecycle, from the documentation made sense as well. When a new file is first seen it is untracked. I checked back up at the previous commands and the new files were indeed \"Untracked files\". After git add the files were in the Staged/Staging-Area, designated as \"Changes to be committed\". My question now was \u00bfhow can I remove these files? I already knew I could delete them normally by right clicking and choosing delete, but this small taste of Command Line Interface (CLI) power had me hooked. I wanted more. I eventually found the command I wanted was git clean . Since I wanted to remove both the remaining untracked files I executed git clean . . As before I watched the directory while I executed the command. Nothing happened. Confused, I then saw the output \"fatal: clean.requireForce...\". Reading the documentation -i was shorthand for --interactive \"Show what would be done and clean files interactively\". Going with that I executed git clean -i . The documentation for interactive mode led me to executing option 1: clean. I forgot to watch the directory to see that they were removed but that didn't matter. At this point I knew I was on my way to learning to understand git.","title":"Restoring from the repo"}]}